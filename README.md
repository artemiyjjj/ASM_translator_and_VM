
# ASM. Транслятор и модель

- P33302, Романов Артемий Ильич
- asm | acc | neum | hw | tick | struct | trap | port | pstr | prob1 | spi
- Без усложнения

## Язык программирования

``` Пример
    section .data:
        message: 12, "Hello World!"
        output_counter: 0
        output_position: 0
    section .text:
    _start:
        ld  message
        st  output_position
    loop:
        ld *output_position
        inc
        st  output_position
        ld  **output_position
        out 3
        ld  *output_counter
        inc
        st  output_counter
        cmp *message
        jnz loop
        hlt
```

Пример программы на разработанном языке

### Синтаксис. Расширенная форма Бэкуса-Наура

``` EnhancedBackusNaurForm
    programm ::= [section .data], section .text ;

    section .data ::=  (label, ":") (<amount of memory words> | <number>, ",", '"', <string>, '"' |
    <number | char>, {"," <number | char | string>}) ;

    section .text ::= <label _start>, ":", {statement}+ ;

    statement ::= [label, ":"], instruction | data defenition, [comment] ;

    instruction ::= no operand opcode | data manipulation opcode, data operand | control flow opcode, control flow operand ;

    no operand opcode ::= "hlt" | "eni" | "dii" | "inc" | "dec" | "nop" | "iret" ;

    unary opcode ::= data manipulation opcode | control opcode ;

    data manipulation opcode ::= "ld" | "st" | "add" | "sub" | "mul" | "div" | "cmp" | "or" | "and" | "out" | "in" ;

    control flow opcode ::= "jmp" | "jz" | "jnz" | "jn" | "jnn" | "int" ;

    operand ::= data operand | control flow operand ;

    data operand ::= number | dereference operator, <number> | <data label> | dereference operator, <data label> ;

    dereference operator ::= "*" ;

    control flow operand ::= <instruction label> ;

    label ::= (<letter> | "_") ({<letter> | <digit> | "_"}) ;

    data defenition ::= data size, ",", [data] ;

    data size ::= <positive integer number> ;

    data ::= <integer number> | '"', <str>, '"' ;

    comment ::= ";", {<any character except '"'>}* ;
```

Код программы выполняется последовательно. Одна инструкция определяет одну машинную команду.

#### Лейблы

Лейблы - названия буквенных меток, указывающих на какой-либо адрес в памяти. Заменяются числовыми адресами на финальном этапе трансляции.

Лейблы могут использоваться для создания обработчиков прерываний. Каждый обработчик прерывания должен вызываться командой **int**, а для корректного завершения работы в конце должен иметь команду **fi** (finish interruption).

> **Важно!** При запуске прерывания в фиксированной области памяти сохраняется состояние процессора, поэтому внутри обработчика прерывания нельзя разрешать прерывания (команда **eni**) и вызывать новые обработчики во избежание потери сохраненного состояния машины.

#### Секции

Программа должна быть поделена на 2 секции: *.data*, *.text*. Каждая секция определяет группу выражений и располагается в последовательно расположенных частях памяти машины, занимаемой программой.

- Секция .data содержит объявления и определения данных с уникальными лейблами. Можно располагать строковые литералы после одной метки внутри двойных кавычек.

- Секция .text содержит инструкции, выполняемые программой. Инструкции могут иметь аргументы, представленные как лейблы, для возможности перехода к необходимиым участкам памяти.

- Все секции могут содержать комментарии (как после выражений, так и занимая целую строку)

Подробнее об инструкциях в разделе [Система команд](#система-команд)

### Семантика

Память выделяется статически, при запуске модели.  
Программе доступна вся память машины.  
Доступно использование p-str с числовым префиксом (длиной).

#### Стратегия вычислений

Доступен вызов по значению, т. е. при всех операциях происходит передача копий значений в аккумулятор; вызов по ссылке - операндом выступает ссылка на ячейку памяти, из которой необходимо извлечь значение. Вычисление (извлечение) выражения, находящегося по данному адресу в памяти происходит лениво - во время выполнения операции микроконтроллером.  

За счёт аккумуляторной архитектуры, используемой машиной, и возможности управления памятью, вызов операций как по ссылке, так и по значению принципиально не отличаются между собой, т.к. ни одна операция, кроме ***store***, не изменяет содержимое памяти - только содержимое аккумулятора. Поэтому можно сказать, что ***стратегия вычислений - вызов по значению***

#### Область видимости

Видимость данных (лейблов) - глобальная.  

#### Типизация

Статическая безтиповая типизация.

Все данные представляются целыми знаковыми числами (последовательностями бит), длиной в машинное слово.  
Благодаря этому, над любыми видами данных можно производить все арифметические и логические опреации.

Стоит отметить, что несмотря на то, что все лейблы преобразуются в индексы паямти, производится проверка лейбла с целью установления его категории во избежание интерпретации данных как команд и наоборот.

#### Виды литералов

Программа поддерживает целочисленные, символьные и строковые литералы.  
Символьные литералы используются только для отображения на память строковых литералов (программисту недоступны).  
Все литералы в памяти машины представлены числами и могут каким-либо образом интерпретироваться вне машины.

Поддержка неизменяемых данных отсутствует. Все данные, объявляемые в программе - изменяемы, за исключением данных, записанных как аргументы инструкций (так как аргументы инструкций не храняться отдельно от них самих). Инструкции неизменяемы.

Программист может создавать "массивы" неинициализированных данных, объявляя лейблы с необходимым количеством элементов в них. Выражение

``` label example
section .data:
    label:   20,
    ...
```

создаст 21 терм данных, представляющих символьные литералы и занимающих 21 ячеек памяти (из-за префикса с длинной литерала), начиная с адреса, ассоциируемого с меткой *label*, и содержащих "0".

Строковые литералы можно объявлять и определять только в формате p-строки.

Для объявления p-строки нужно после длинны строки указать её содержимое (см. файл [hello.asm](/examples/hello.asm)).
При этом, в памяти по адресу лейбла строки будет находиться длина строки (в ячейках памяти), и лишь после неё будут располагаться непосредственно символы строки.

Подробнее о представлении литералов: [секция Модель памяти процессора](#работа-с-элементами-программы)

## Организация памяти

### Модель памяти процессора

- Общая память для команд и для данных.
- Машинное слово - 32 бита, знаковое.
- Единица данных и одна команда занимают 1 машинное слово (для упрощения, числовые аргументы инструкций могут быть любой длины).
- Линейное адресное пространство.
- Адресуемая единица памяти - 1 машинное слово (32 бита).

#### Работа с элементами программы

Динамические (изменяемые) данные хранятся в секции данных, после инструкций. Они загружаются в память одновременно с загрузкой выражений команд и размещаются в том же порядке, как и в исходном коде программы.

Статические данные не поддерживаются языком, за исключением "hardcoded" аргументов инструкций. Такие литералы не сохраняются в памяти за пределами области хранения иинструкции и используются при помощи копирования из тела инструкции.

Литералы, требующие для хранения несколько машинных слов, "разбиваются" на этапе трансляции на необходимое количество символьных или целочисленных литералов, в машинном коде представляющих из себя термы данных длиной 1 машинное слово, имеющие префикс, содержащий значение количества термов данных этого литерала.  

Так как максимально возможное одновременно адресуемое количество данных совпадает с размером регистра (1 машинное слово) и отсутствует возможность одновременной обработки всех членов строковых литералов и массивов, то любые адресуемые данные могут быть загружены в регистр.

Поддержка процедур как таковых отсутсвтует в языке и заменена использованием безусловных и условных переходов на участки памяти команд с помощью меток во время исполнения. Метки и их расположение в памяти фиксируется и проверяется на корректность на этапе трансляции и окончательно остаётся в интрукции в форме адреса памяти на этапе замены лейблов на числовые значения в аргументах команд.

Адреса прерываний, область памяти для сохранения состояния регистров машины перед запуском прерывания и стандартный обработчик прерываний находятся в начале памяти.  
Программные прерывания запускаются с номером прерывания, который совпадает с адресом, указывающим на адрес начала обработчика прерываний.
Аппаратные прерывания запускаются на обработчике с номером, соответсвующем номеру устрйоства (по умолчанию доступны 1-7).  
Подробнее о размещении обработчиков прерываний в разделе [Механика отображения программы и данных на память](#механика-отображения-программы-и-данных-на-память)  
и об организации прерываний в разделе [Система команд / Прерывания](#прерывания))

### Механика отображения программы и данных на память

Программисту доступно всё адресное пространсто памяти и аккумуляторный регистр, через который происходят все операции по манипуляции данными.

- В начале каждой программы отведено **11 ячеек памяти** для хранения адресов обработчиков прерываний (8 адресов) + место для сохранения аккумулятора и счётчика команд перед переходом к прерыванию (2 машинных слова) + стандартный обработчик прерываний (команда *fi*).
- Инструкция, имеющая метку **_start**, помещается в память по адресу **12**, с которого начнётся выполнение программы.
- Все инструкции, располагающиеся за этой меткой, помещаются в том же порядке, как в программе.
- Все инструкции, располагающиеся до этой метки, располагаются за уже расположенными инструкциями с сохранением порядка. (**необходимо учитывать при написании программ!**)
- Данные помещаются за всеми командами с сохранением порядка (например, это позволяет использовать всю оставшуюся после программы память как стек).

## Система команд

Особенности процессора:

- Машинное слово - 32 бит, знаковое.
- Инструкции выполняются по циклам.
- В цикле выборки команды доступ к памяти осуществляется по адресу, хранящемуся в регистре PC (Programm Counter). Установка адреса осуществляется путём инкрементирования значения PC или передачей значения из регистра IR.
- В остальных циклах, доступ к памяти осуществляется по адресу, хранящемуся в регистре AR (adress register). Установка адреса осуществляется путём передачи значения из одного из регистров BR, IR, или фиксированных значений адресов памяти, обозначающих ячейки, в которые сохраняются значения регистров AC и PC при подготовке к прерыванию.
- Поток управления представляет собой инкрементирование регистра PC в цикле выборки инструкции или загрузкой значения в регистр PC при прерываниях или командах управления потоком выполнения.
- О системе прерываний ([работа с элементами программы](#работа-с-элементами-программы))
- Ввод/вывод (см. раздел [ввод / вывод](#ввод--вывод))

### Адресация данных и команд

Поддерживается непосредственный (VALUE), прямой (DIRECT) и косвенный (INDIRECT) способы адресации.  
В первом случае, аргумент команды интерпретируется как значение, во втором - лейбл или число будут интерпретированы как адрес памяти, по которому находится значение, в третьем случае - лейбл или число будут интерпретированы как адрес, по которому в памяти находится адрес искомого значения.

Таким образом

- аргумент является значением - **VALUE** (в т.ч. загрузка адреса ячейки памяти по лейблу)
- аргумент инструкции представляет собой адрес, по которому в памяти располагается искомое значение - **DIRECT**
- аргумент инструкции представляет собой адрес, по которому в памяти располагается адрес, по которому располагается искомое значение - **INDIRECT**

Наличие нескольких уровней косвенности расширяет возможности программиста по манипулированию данными, например, позволяет хранить в памяти адрес текущего элемента массива или строкогого литерала с возможностью загрузки его в аккумулятор одной инструкцией.

### Инструкции

Инструкция может быть двух видов:

- без операндов (не требующая аргументов)

- унарной (требовать 1 аргумент)

Унарные двух категорий:

- Управления потоком данных

- Манипуляции данными

В инструкциях с аргументами, последние могут быть значениями, указателями на значение в памяти, указателями на указатель на значение в памяти и значениями по адресу ячейки памяти.  
По умолчанию, числа интерпретируются как значения, а лейблы как адреса. Для обращения интерпретации чисел как адресов, а лейблов - как значений по адресу, перед ними следуюет поставить символ "*".

#### Набор инструкций

| Оператор | Инструкция | Операнды | Кол-во тактов | Описание |  
|---|---|---|---|---|  
| ld | Load | адрес / значение по адресу | 5 - 8 | Загрузка в аккумулятор значения из памяти по указанному адресу |  
| st | Store | адрес | 6 - 9 | Запись в память по указанному адресу значения из аккумулятора |  
| in | Input | номер порта | 5 | Ввод значения с указанного порта в аккумулятор |  
| out| Output | номер порта | 5 | Вывод значения из аккумулятора на указанный порт вывода |  
| add | Addition | значение по адресу / значение | 5 - 8 | Сложение значения параметра с значением из аккумулятора с последующей записью результата в аккумулятор |  
| sub | Substraction | значение по адресу / значение | 5 - 8 | Вычитание значения аргумента из значения аккумулятора с последующей записью результата в аккумулятор |  
| cmp | Compare | значение по адресу / значение | 5 - 8 | Вычитание значения аргумента из значения аккумулятора без записи результата в аккумулятор |  
| inc | Increment | - | 5 | Инкрементация значения аккумулятора |  
| dec | Decrement | - | 5 | Декрементация значения аккумулятора |  
| mul | Multiplication | значение по адресу / значение | 5 - 8 | Умножение значения параметра с значением из аккумулятора с последующей записью в аккумулятор |  
| div | Division | значение по адресу / значение | 5 - 8 | Деление значения из аккумулятора с значением параметра с последующей записью в аккумулятор |  
| mod | modulo | значение по адресу / значение | 5 - 8 | Получение остатка от деления значения из аккумулятора со значением параметра с последующей записью в аккумулятор |  
| or | Logical "Or" | значение по адресу / значение | 5 - 8 | Логическое "ИЛИ" между аккумулятором и значением параметра с последующей записью результата в аккумулятор. |  
| and | Logical "And" | значение по адресу / значение | 5 - 8 | Логическое "И" между аккумулятором и значением параметра с последующей записью в аккумулятор. |  
| lsl | Logical bit shift left | - | 5 | логический сдвиг битов аккумулятора влево |  
| asr | Arithmetic bit shift right | - | 5 | арифметический сдвиг битов аккумулятора вправо |  
| jmp | Jump | адрес инструкции | 5 - 8 | Безусловное изменение значения регистра-счётчика команд (PC) на значение параметра. |  
| jz | Jump if Zero | адрес инструкции | 6 - 9 | Изменение значения регистра IP на значение параметра при значении 1 в регистре Z. |  
| jnz | Jump if Not Zero | адрес инструкции | 6 - 9 | Изменение значения регистра PC на значение параметра при значении 0 в аккумуляторе. |  
| jn | Jump if Negative | адрес инструкции | 6 - 9 | Изменение значения регистра PC на значение параметра при значении 1 в аккумуляторе. |  
| jp | Jump if Positive | адрес инструкции | 6 - 9 | Изменение значения регистра PC на значение параметра при значении 0 в аккумуляторе. |  
| int | interuption | номера обработчика прерывания | 12 | Вызов определенного обработчика прерываний |  
| fi | finish interruption | - | 8 | Завершить обработку прерывания, вернуть аккумулятор и PC в состояние "как до прерывания" |  
| eni | enable interution | - | 5 | Разрешить прерывания |  
| dii | disable interuption | - | 5 | Запретить прерывания |  
| nop | no operation | - | 5 | Ничего не выполнять |
| hlt | halt | - | 4 | Остановить работу машины |

### Кодирование инструкций и данных

- Машинный код сериализуется в список формата JSON.
- Один элемент списка - одна машинная инструкция или ячейка с данными.
- Индекс списка - адрес инструкции в памяти и адрес инструкции в машинном коде. Используется для команд перехода и адресации данных.

Пример:

``` machine code
[
    {
        "index": 0,
        "opcode": "jmp",
        "arg": 1,
        "mode": "direct",
        "line": 2
    },
    {
        "index": 1,
        "label": "a",
        "value": "x",
        "line": 4
    }
]
```

В примере, представленом выше:

- index - место выражения в памяти при работе программы.
- opcode - код инструкции.
- arg - аргумент инструкции, если предусмотрен конкретной инструкцией.
- mode - способ адресации данных в инструкциях.
- label - метка ячейки памяти для упрощения (программисту) доступа к ней на этапе написаниия программы.
- value - значение терма данных, сохраняемое в памяти.
- line - местоположение инструкции в исходном коде программы.

Стуктуры для реализации инструкций и данных (файл [isa.py](/src/isa.py)):

- Opcode - перечисление кодов инструкций.
- SourceTerm - выражение, представляющее собой одну строку исходного кода, разделённую через специальные символы.
- StatementTerm - Opcode инструкции и её аргумент (опционально), а также индекс в памяти, место в исходном коде, режим адресации аргумента (опционально) и лейбл в исходном коде (опционально)

### Устройство ввода/вывода

См. раздел [Ввод / вывод](#ввод--вывод)

### Поток управления

- инкремент значения PC после каждой инструкции.
- инструкции для осуществления условного (jz) и безусловного (jmp) переходов.
- прерывания (см. разделы [Прерывания](#прерывания) и [Ввод/Вывод](#ввод--вывод))

#### Прерывания

Прерывания могут быть программными и аппаратными. Аппаратные прерывания маскируемы, т.е. могут быть проигнорированны исходя из состояния флага разрешения прерываний в CU, однако программные прерывания могут быть вызваны всегда (т.к. процессор с одним потоком управления и другое программное прерывание не может быть вызвано неявно для программиста).  

Маскирование (запрет) аппаратных прерываний осуществляется установкой флага IE в "0" (по умолчанию), а разрешение - "1".

Поддержка запрета прерываний также зависит от флага IS, отображающего, происходит ли сейчас в машине обработка прерывания. Меняет состояние в _prepare_interruption и при команде *fi*.

Вызов аппаратных прерываний происходит во время [цикла обработки прерывания](#циклы-исполнения-команд) при условии, что IE в состоянии "1" и IS = "0".

Перед началом прерывания значения аккумулятора и счётчика команд сохраняются на фиксированные ячейки памяти для продолжения работы программы после прерывания.
Прерывания должны исполняться последовательно, чтобы выполнение программы полсле обработки прерывания могло быть продолжено корректно.

Обработчики прерываний (см. раздел [Отображение данных на память](#механика-отображения-программы-и-данных-на-память)) хранятся в *векторе прерываний*. По умолчанию, вектор прерываний инициализирован указателем на стандартный обработчик прерывания, состоящий из инструкции *fi*, что защищает программиста от случайного разрешения прерываний, но при необходимости использования аппаратных прерываний, программист должен создать обработчики прерываний и вручную заполнить вектор прерывания адресами обработчиков (см. [пример](/examples/io_example.asm)).
Каждый элемент в векторе прерываний отвечает за устройство ввода/вывода, подключённое к шине даннх с номером, соответсвующим номеру элемента вектора прерывания. Однако нет необходимости писать одинаковые обработчики - можно загрузить в разные элементы вектора прерывания одинаковые адреса обработчиков прерываний.

Итак, программист должен:

- Создавать обработчики прерываний
- В начале программы загружать адреса обработчиков прерываний в соответствующие элементы вектора прерываний

## Транслятор

Производит трансляцию кода на разработаном диалекте ассемблера в машинный код формата JSON для разработанной машины.

### Интерфейс командной строки

Представляет собой python-скрипт, работающий как консольное приложение - при запуске требуется 2 аргумента:

- файл с исходным кодом на ассемблере
- файл, в который следует сохранить машинный код

### Принцип работы

1. На вход скрипта принимается исходный код на ассемблере.
2. Происходит разделение каждой строки исходного кода на термы.
3. Термы разделяются на две логические секции: данные и инструкции.
4. Производится преобразование и валидация термов из секции данных в термы данных.
5. Производится преобразование и валидация термов из секции инструкций в термы инструкций.
6. Производится отображение всех полученных термов на адресное пространство памяти.
7. Происходит преобразование лейблов - аргументов инструкций в адреса, на которые лейблы указывают.
8. Полученный машинный код сохраняется в целевой файл.

Примечание: вопросы отображения переменных на регистры опущены из-за отсутствия переменных на синтаксическом уровне.

## Модель процессора

### DataPath

![Схема Data Path](/images/DataPath.png)

Реализован в классе DataPath.

Сигналы обрабатываются за один такт и представлены сигналами защёлкивания определённых компонентов (в реализации выбор источника данных, который "откроет" выходную линию регистра-источника и защёлкнет в регистр-приемник). Реализованы в Control Unit

- signal_latch_address_register (sel_buff_reg, sel_instr_reg, sel_int_reg, latch_adress_reg) - запись в адресный регистр
- signal_latch_accumulator_register (sel_mem, sel_io_data, sel_alu, sel_pc, latch_acc) - запись в аккумулятор
- signal_latch_buffer_register (sel_mem, sel_int0, sel_instr_arg, latch_buf) - запись в буфферный регистр
- signal_latch_arithmetical_logical_unit (sel_inputs, sel_inversion, sel_inc, sel_dec, sel_operation) - запись в АЛУ
- read_memory - чтение памяти
- write_memory - запись в память

### Control Unit

![Схема Control Unit](/images/CU.png)

Сигналы:

- perform tick - счётчик тактов
- dii - запрет прерываний
- eni - разрешение прерываний
- select_pc, latch_programm_counter - запись в счётчик команд

### Ввод / вывод

![Схема ввода/вывода](/images/io_design.png)

Осуществляется посредством передачи управляющих (и прерывания) сигналов и передачи данных из машины в устройства ввода / вывода через контроллер ввода вывода и шину данных. Устройства могут запрашивать прерывания через запрос на линию прерываний.
Устройства должны подключаться к шине данных машины (что реализовано в модуле [machine.py](src/machine.py)). Сигналы передаются через именованные подключенные линии данных через контроллер ввода/вывода.

В симуляции можно задать расписание поступаемых на какое-либо устройство данных и логику совершения запросов прерываний

#### Контроллер ввода / вывода

Контроллер состоит из демультиплексора, преобразующего  получающего управляющий сигнал из буферного регистра, в сигнальную линию, характерезующую управляющий сигнал для определенного устройства.

#### Устройства ввода / вывода

![Устройство ввода / вывода](/images/io_device.png)

Состоят из 8-и битного регистра данных и битовых регистров прерываний: INT, NEW, а также имеют порты для получения управляющих сигналов, которые заставляют устройство принимать / писать данные со своих регистров на шину данных или линию прерываний.

Отдельный класс устройств, при запросе на чтение из которых происходит предложение ввести данные в консоль симуляции, сохранение введённых данных и загрузка их в регистр данных устройства при запросе чтения.

#### Циклы исполнения команд

1. Выборки команды

2. Выборки операнда

3. Выполнения

4. Проверки прерывания

## Тестирование

Разработаны модульные тесты для следующих модулей проекта:

- Системы команд
- Транслятора
- Машины

А так же интергационные тесты для всех вышеперечисленных и Устройств ввода/вывода

### Настройка CI

CI сконфигурирован для использования платформы GitLab. Создаётся Docker - образ, содержащий последнюю версию интерпретатора Python, образ загружается на облачные сервера GitLab, происходит настройка окружения для проведения необходимых работ (загрузка необходимых пакетов) и запускаются работы.

Работы (jobs), проводимые при запуске CI:

- test-coverage - "прогон" тестов с утилитой coverage.
- lint - проверка исходного кода на python линтером ruff.
- type-check - проверка типизации исходного кода на python инструментом mypy.

```text
| ФИО                            | алг   | LoC | code байт | code инстр. | инстр. | такт. | вариант |
| Романов А. И. | hello | ... | -         | ...         | ...    | ...   | ...     |
| Романов А. И. | cat   | 1   | -         | 6           | 15     | 28    | ...     |
```
