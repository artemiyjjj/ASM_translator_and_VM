
# ASM. Транслятор и модель

- P33302, Романов Артемий Ильич
- asm | acc | neum | hw | tick | struct | trap | port | pstr | prob1 | spi
- С усложнением

## Язык программирования

### Синтаксис. Расширенная форма Бэкуса-Наура

``` EnhancedBackusNaurForm
    programm ::= [section .data], section .text ;

    section .data ::=  (label, ":") (<amount of memory words> | <number>, ",", '"', <string>, '"' |
    <number | char>, {"," <number | char | string>}) ;

    section .text ::= <label _start>, ":", {statement}+ ;

    statement ::= [label, ":"], instruction | data defenition, [comment] ;

    instruction ::= no operand opcode | data manipulation opcode, data operand | control flow opcode, control flow operand ;

    no operand opcode ::= "hlt" | "eni" | "dii" | "inc" | "dec" | "nop" | "iret" ;

    unary opcode ::= data manipulation opcode | control opcode ;

    data manipulation opcode ::= "ld" | "st" | "add" | "sub" | "mul" | "div" | "cmp" | "or" | "and" | "out" | "in" ;

    control flow opcode ::= "jmp" | "jz" | "jnz" | "jn" | "jnn" | "int" ;

    operand ::= data operand | control flow operand ;

    data operand ::= number | dereference operator, <number> | <data label> | dereference operator, <data label> ;

    dereference operator ::= "*" ;

    control flow operand ::= <instruction label> ;

    label ::= (<letter> | "_") ({<letter> | <digit> | "_"}) ;

    data defenition ::= data size, ",", [data] ;

    data size ::= <positive integer number> ;

    data ::= <integer number> | '"', <str>, '"' ;

    comment ::= ";", {<any character except '"'>}* ;
```

Код программы выполняется последовательно. Одна инструкция определяет одну машинную команду

#### Лейблы

Лейблы - названия буквенных меток, указывающих на какой-либо адрес в памяти. Заменяются числовыми адресами на этапе соединения секций при трансляции.

#### Секции

Программа поделена на 2 секции: .data, .text. Каждая секция определяет группу выражений и располагается в последовательно расположенных частях памяти машины, занимаемой программой.

- Секция .data содержит объявления и определения данных с уникальными лейблами. Можно располагать массивы данных одинкаового размера после одной общей метки через запятую.

- Секция .text содержит операции, совершаемые программой, которые могут иметь метки для возможности перехода к ним с помощью команд управления потоком выполнения.

- Все секции могут содержать комментарии (как после выражений, так и в целой строке)

### Инструкции

Инструкция может быть двух видов:

- без операндов (не требующая аргументов)

- унарной (требовать 1 аргумент)

В инструкциях с аргументами, последние могут быть значениями, указателями на значение в памяти, указателями на указатель на значение в памяти и значениями по адресу ячейки памяти.  
По умолчанию, числа интерпретируются как значения, а лейблы как адреса. Для обращения интерпретации чисел как адресов, а лейблов - как значений по адресу, перед ними следуюет поставить символ "*".


### Семантика

Память выделяется статически, при запуске модели.  
Видимость данных (лейблов) - глобальная.  
Доступно использование p-str с числовым префиксом (длиной).

#### Стратегия вычислений

Используемая стратегия вычислений в языке не одна.  
Доступен вызов по значению, т. е. при всех операциях происходит передача копий значений в аккумулятор; вызов по ссылке - операндом выступает ссылка на ячейку памяти, из которой необходимо извлечь значение. Вычисление (извлечение) выражения, находящегося по данному адресу в памяти происходит лениво - во время выполнения операции микроконтроллером.  

За счёт аккумуляторной архитектуры, используемой машиной, и возможности управления памятью, вызов операций как по ссылке, так и по значению принципиально не отличаются между собой, т.к. ни одна операция, кроме ***store***, не изменяет содержимое памяти - только содержимое аккумулятора. Поэтому можно сказать, что *стратегия вычислений - вызов по значению*

#### Область видимости

Видимость данных (лейблов) - глобальная.  

#### Типизация

Статическая безтиповая типизация.

Все данные кроме знаковых чисел представляются целыми беззнаковыми числами (последовательностями бит).  
Благодаря этому, над любыми видами данных можно производить все арифметические и логические опреации.

Стоит отметить, что несмотря на то, что все лейблы преобразуются в индексы паямти, производится проверка лейбла с целью установления его категории во избежание интерпретации данных как команд и наоборот.

#### Виды литералов

Программа поддерживает целочисленные и строковые литералы.

Поддержка неизменяемых данных отсутствует. Все данные, объявляемые в программе - изменяемы.

Программист может создавать "массивы" неинициализированных данных, объявляя лейблы с необходимым количеством элементов в них. Выражение

``` label example
section .data:
    label:   20,
    ...
```

создаст терм данных, занимающий 20 ячеек памяти, начиная с адреса, ассоциируемому с меткой *label*.

Строковые литералы можно объявлять и определять только в формате p-строки.

Для объявления p-строки нужно после длинны строки указать её содержимое (см. файл [hello.asm](/examples/hello.asm)).
При этом, в памяти по адресу лейбла строки будет находиться длина строки (в ячейках памяти), и лишь после неё будут располагаться непосредственно символы строки.

## Организация памяти

Модель памяти процессора:

- Общая память для команд и для данных.
- Машинное слово - 32 бита, знаковое.
- Линейное адресное пространство.
- Адресуемая единица памяти - 4 байт.

Программисту доступно всё адресное пространсто памяти и аккумуляторный регистр, через который происходят все операции по манипулированию данными.

Механика отображения программы и данных на память:

- В начале каждой программы отведено **40 байт** (10 ячеек памяти) для хранения адресов обработчиков прерываний (8 адресов) + место для сохранения аккумулятора и счётчика команд перед переходом к прерыванию (2 машинных слова).
- Инструкция, имеющая метку **_start**, помещается в память по адресу **40**, с которого начнётся выполнение программы.
- Все инструкции, располагающиеся за этой меткой, помещаются в том же порядке, как в программе.
- Все инструкции, располагающиеся до этой метки, располагаются за уже расположенными инструкциями с сохранением порядка. (**необходимо учитывать при написании программ!**)
- Данные помещаются за всеми командами с сохранением порядка (например, это позволяет использовать всю оставшуюся после программы память как стек).



## Система команд

Особенности процессора:

- Машинное слово - 32 бит, знаковое.
- Доступ к памяти осуществляется по адресу, хранящемуся в регистре AR (adress register)

### Адресация данных и команд

Поддерживается косвенный и прямой способы адресации - в первом случае, лейбл или число будут интерпретированы непостредственно как адрес памяти, во втором случае - как значение, лежащее по этому лейблу или адресу.  
Машина (и язык) поддерживают 2 уровня косвенности:

- аргумент инструкции представляет собой адрес, по которому в памяти располагается искомое значение.
- аргумент инструкции представляет собой адрес, по которому в памяти располагается адрес, по которому располагается искомое значение.

Наличие нескольких уровней косвенности расширяет возможности программиста по манипулированию данными, например, позволяет хранить в памяти адрес текущего элемента массива или строкогого литерала с возможностью загрузки его в аккумулятор одной инструкцией.

## Набор инструкций

| Оператор | Инструкция | Операнды | Кол-во тактов | Описание |  
|---|---|---|---|---|  
| ld | Load | адрес / значение по адресу | ? | Загрузка в аккумулятор значения из памяти по указанному адресу |  
| st | Store | адрес | ? | Запись в память по указанному адресу значения из аккумулятора |
| add | Addition | значение по адресу / значение | ? | Сложение значения параметра с значением из аккумулятора с последующей записью результата в аккумулятор |  
| sub | Substraction | значение по адресу / значение | ? | Вычитание значения параметра из значения из аккумулятора с последующей записью результата в аккумулятор |  
| mul | Multiplication | значение по адресу / значение | ? | Умножение значения параметра с значением из аккумулятора с последующей записью в аккумулятор |  
| div | Division | значение по адресу / значение | ? | Деление значения из аккумулятора с значением параметра с последующей записью в аккумулятор |  
| mod | modulo | значение по адресу / значение | ? | Получение остатка от деления значения из аккумулятора со значением параметра с последующей записью в аккумулятор |  
| or | Logical "Or" | значение по адресу / значение | ? | Логическое "ИЛИ" между аккумулятором и значением параметра с последующей записью результата в аккумулятор. |  
| and | Logical "And" | значение по адресу / значение | ? | Логическое "И" между аккумулятором и значением параметра с последующей записью в аккумулятор. |  
| lsl | Logical bit shift left | - | ? | логический сдвиг битов аккумулятора влево |  
| lsr | Logical bit shift right | - | ? | логический сдвиг битов аккумулятора вправо |  
| jmp | Jump | адрес инструкции | ? | Безусловное изменение значения регистра-счётчика команд (PC) на значение параметра. |  
| jz | Jump if Zero | адрес инструкции | ? | Изменение значения регистра IP на значение параметра при значении 1 в регистре Z. |  
| jnz | Jump if Not Zero | адрес инструкции | ? | Изменение значения регистра PC на значение параметра при значении 0 в аккумуляторе. |  
| jn | Jump if Negative | адрес инструкции | ? | Изменение значения регистра PC на значение параметра при значении 1 в аккумуляторе. |  
| jp | Jump if Positive | адрес инструкции | ? | Изменение значения регистра PC на значение параметра при значении 0 в аккумуляторе. |  
| int | interuption | номера обработчика прерывания | ? | Вызов определенного обработчика прерываний |  
| fi | finish interruption | - | ? | Завершить обработку прерывания, вернуть аккумулятор и PC в состояние "как до прерывания" |  
| eni | enable interution | - | ? | Разрешить прерывания |  
| dii | disable interuption | - | ? | Запретить прерывания |  
| nop | no operation | - | ? | Ничего не выполнять |
| hlt | halt | - | ? | Остановить работу машины |

## Кодирование инструкций

- Машинный код сериализуется в список формата JSON.
- Один элемент списка - одна машинная инструкция.
- Индекс списка - адрес инструкции в памяти и адрес инструкции в машинном коде. Используется для команд перехода.

Пример:

``` machine code
[
    {
        "index": 0,
        "opcode": "jmp",
        "arg": 1,
        "mode": "deref",
        "line": 2
    },
    {
        "index": 1,
        "label": "a",
        "value": "x",
        "line": 4
    }
]
```

В примере, представленом выше:

- opcode - строка с кодом инструкции.
- arg - аргумент, если имеется.
- position - местоположение инструкции в исходном коде программы.

Типы данных для реализации инструкций (файл [isa.py](/src/isa.py)):

- Opcode - перечисление кодов инструкций.
- StatementTerm - структура для описания местоположения позиции инструкции в исходном коде. ???

## Транслятор

Производит трансляцию кода на разработаном диалекте ассемблера в машинный код формата JSON для разработанной машины.

### Интерфейс командной строки

Представляет собой python-скрипт, работающий как консольное приложение - при запуске требуется 2 аргумента:

- файл с исходным кодом на ассемблере
- файл, в который следует сохранить машинный код

### Принцип работы

1. На вход скрипта принимается исходный код на ассемблере.
2. Происходит разделение каждой строки исходного кода на термы.
3. Термы разделяются на две логические секции: данные и инструкции.
4. Производится преобразование и валидация термов из секции данных в термы данных.
5. Производится преобразование и валидация термов из секции инструкций в термы инструкций.
6. Производится отображение всех полученных термов на адресное пространство памяти.
7. Происходит преобразование лейблов - аргументов инструкций в адреса, на которые лейблы указывают.
8. Полученный машинный код сохраняется в целевой файл.

Примечание: вопросы отображения переменных на регистры опущены из-за отсутствия переменных на синтаксическом уровне.

## Модель процессора

### DataPath

...

### Control Umit

...

## Тестирование

Разработаны модульные тесты для следующих модулей проекта:

- Системы команд
- Транслятора
- Машины

А так же интергационные тесты для всех вышеперечисленных и Устройств ввода/вывода

### Настройка CI

CI сконфигурирован для использования платформы GitLab. Создаётся Docker - образ, содержащий последнюю версию интерпретатора Python, образ загружается на облачные сервера GitLab, происходит настройка окружения для проведения необходимых работ (загрузка необходимых пакетов) и запускаются работы.

Работы (jobs), проводимые при запуске CI:

- test-coverage - "прогон" тестов с утилитой coverage.
- lint - проверка исходного кода на python линтером ruff.
- type-check - проверка типизации исходного кода на python инструментом mypy.

### Базовые тесты
