
# ASM. Транслятор и модель

- P33302, Романов Артемий Ильич
- asm | acc | neum | hw | tick | struct | trap | port | pstr | prob1 | spi
- С усложнением

## Язык программирования

### Синтаксис. Расширенная форма Бэкуса-Наура

``` EnhancedBackusNaurForm
    programm ::= [section .data], section .text ;

    section .data ::=  (label, ":") (<amount of memory words> | <number>, ",", '"', <string>, '"' |
    <number | char>, {"," <number | char | string>}) ;

    section .text ::= <label _start>, ":", {statement}+ ;

    statement ::= [label, ":"], instruction | data defenition, [comment] ;

    instruction ::= no operand opcode | data manipulation opcode, data operand | control flow opcode, control flow operand ;

    no operand opcode ::= "hlt" | "eni" | "dii" | "inc" | "dec" | "nop" | "iret" ;

    unary opcode ::= data manipulation opcode | control opcode ;

    data manipulation opcode ::= "ld" | "st" | "add" | "sub" | "mul" | "div" | "cmp" | "or" | "and" | "out" | "in" ;

    control flow opcode ::= "jmp" | "jz" | "jnz" | "jn" | "jnn" | "int" ;

    operand ::= data operand | control flow operand ;

    data operand ::= number | dereference operator, <number> | <data label> | dereference operator, <data label> ;

    dereference operator ::= "*" ;

    control flow operand ::= <instruction label> ;

    label ::= (<letter> | "_") ({<letter> | <digit> | "_"}) ;

    data defenition ::= data size, ",", [data] ;

    data size ::= <positive integer number> ;

    data ::= <integer number> | '"', <str>, '"' ;

    comment ::= ";", {<any character except '"'>}* ;
```

Код программы выполняется последовательно. Одна инструкция определяет одну машинную команду

#### Лейблы

Лейблы - названия буквенных меток, указывающих на какой-либо адрес в памяти. Заменяются числовыми адресами на этапе соединения секций при трансляции.

Лейблы могут использоваться для создания обработчиков прерываний. Каждый обработчик прерывания должен вызываться командой **int**, а для корректного завершения работы в конце должен иметь команду **fi** (finish interruption).

> **Важно!** При запуске прерывания в фиксированной области памяти сохраняется состояние процессора, поэтому внутри обработчика прерывания нельзя разрешать прерывания (команда **eni**) и вызывать новые обработчики во избежание потери сохраненного состояния машины.

#### Секции

Программа поделена на 2 секции: .data, .text. Каждая секция определяет группу выражений и располагается в последовательно расположенных частях памяти машины, занимаемой программой.

- Секция .data содержит объявления и определения данных с уникальными лейблами. Можно располагать массивы данных одинкаового размера после одной общей метки через запятую.

- Секция .text содержит операции, совершаемые программой, которые могут иметь метки для возможности перехода к ним с помощью команд управления потоком выполнения.

- Все секции могут содержать комментарии (как после выражений, так и в целой строке)

Подробнее об инструкциях в разделе [Система команд](#система-команд)

### Семантика

Память выделяется статически, при запуске модели.  
Видимость данных (лейблов) - глобальная.  
Доступно использование p-str с числовым префиксом (длиной).

#### Стратегия вычислений

Используемая стратегия вычислений в языке не одна.  
Доступен вызов по значению, т. е. при всех операциях происходит передача копий значений в аккумулятор; вызов по ссылке - операндом выступает ссылка на ячейку памяти, из которой необходимо извлечь значение. Вычисление (извлечение) выражения, находящегося по данному адресу в памяти происходит лениво - во время выполнения операции микроконтроллером.  

За счёт аккумуляторной архитектуры, используемой машиной, и возможности управления памятью, вызов операций как по ссылке, так и по значению принципиально не отличаются между собой, т.к. ни одна операция, кроме ***store***, не изменяет содержимое памяти - только содержимое аккумулятора. Поэтому можно сказать, что *стратегия вычислений - вызов по значению*

#### Область видимости

Видимость данных (лейблов) - глобальная.  

#### Типизация

Статическая безтиповая типизация.

Все данные кроме знаковых чисел представляются целыми беззнаковыми числами (последовательностями бит), длиной в машинное слово.  
Благодаря этому, над любыми видами данных можно производить все арифметические и логические опреации.

Стоит отметить, что несмотря на то, что все лейблы преобразуются в индексы паямти, производится проверка лейбла с целью установления его категории во избежание интерпретации данных как команд и наоборот.

#### Виды литералов

Программа поддерживает целочисленные, символьные и строковые литералы.  
Символьные литералы используются только для отображения на память строковых литералов.

Поддержка неизменяемых данных отсутствует. Все данные, объявляемые в программе - изменяемы, за исключением данных, записанных как аргументы инструкций.

Программист может создавать "массивы" неинициализированных данных, объявляя лейблы с необходимым количеством элементов в них. Выражение

``` label example
section .data:
    label:   20,
    ...
```

создаст 20 термов данных, представляющих символьные литералы и занимающих 20 ячеек памяти, начиная с адреса, ассоциируемому с меткой *label*.

Строковые литералы можно объявлять и определять только в формате p-строки.

Для объявления p-строки нужно после длинны строки указать её содержимое (см. файл [hello.asm](/examples/hello.asm)).
При этом, в памяти по адресу лейбла строки будет находиться длина строки (в ячейках памяти), и лишь после неё будут располагаться непосредственно символы строки.

Подробнее о работе с литералами: [секция Модель памяти процессора](#работа-с-элементами-программы)

## Организация памяти

### Модель памяти процессора

- Общая память для команд и для данных.
- Машинное слово - 32 бита, знаковое.
- Единица данных и одна команда занимают 1 машинное слово (для упрощения, числовые аргументы инструкций могут быть любой длины).
- Линейное адресное пространство.
- Адресуемая единица памяти - 1 машинное слово (32 бита).

#### Работа с элементами программы

Динамические (изменяемые) данные хранятся в секции данных, после инструкций. Они загружаются в память одновременно с загрузкой выражений команд и размещаются в том же порядке, как и в исходном коде программы.

Статические данные не поддерживаются языком, за исключением "hardcoded" аргументов. Такие литералы не сохраняются в памяти за пределами области хранения иинструкции и используются при помощи копирования из тела выражения команды.

Литералы, требующие для хранения несколько машинных слов, "разюиваются" на этапе трансляции на необходимое количество символьных или целочисленных литералов, в машинном коде представляющих из себя термы данных длиной 1 машинное слово.  

Так как максимально возможное одновременно адресуемое количество данных совпадает с размером регистра (1 машинное слово) и отсутствует возможность одновременной обработки всех членов строковых литералов и массивов, то все данные могут быть загружены в регистр.

Поддержка процедур как таковых отсутсвтует в языке и заменена использованием безусловных и условных переходов на участки памяти команд с помощью меток во время исполнения. Метки и их расположение в памяти фиксируется и проверяется на корректность на этапе трансляции и окончательно остаётся в интрукции в форме адреса памяти на этапе замены лейблов в аргументах команд.

Адреса прерываний и область памяти для сохранения состояния регистров машины перед запуском прерывания находятся в начале памяти.  
Программные прерывания запускаются с номером прерывания, который совпадает с адресом, указывающим на адрес начала обработчика прерываний.
Аппаратные прерывания требуют наличие таблицы прерываний, определяющей номер обработчика прерывания для каждого подключённого устройства.  
Подробнее о размещении обработчиков прерываний в разделе [Механика отображения программы и данных на память](#механика-отображения-программы-и-данных-на-память)  
и об организации прерываний в разделе [Система команд / Прерывания](#прерывания))

### Механика отображения программы и данных на память

Программисту доступно всё адресное пространсто памяти и аккумуляторный регистр, через который происходят все операции по манипуляции данными.

- В начале каждой программы отведено **10 ячеек памяти** (40 байт) для хранения адресов обработчиков прерываний (8 адресов) + место для сохранения аккумулятора и счётчика команд перед переходом к прерыванию (2 машинных слова).
- Инструкция, имеющая метку **_start**, помещается в память по адресу **10**, с которого начнётся выполнение программы.
- Все инструкции, располагающиеся за этой меткой, помещаются в том же порядке, как в программе.
- Все инструкции, располагающиеся до этой метки, располагаются за уже расположенными инструкциями с сохранением порядка. (**необходимо учитывать при написании программ!**)
- Данные помещаются за всеми командами с сохранением порядка (например, это позволяет использовать всю оставшуюся после программы память как стек).

## Система команд

Особенности процессора:

- Машинное слово - 32 бит, знаковое.
- Доступ к памяти осуществляется по адресу, хранящемуся в регистре AR (adress register)

### Адресация данных и команд

Поддерживается непосредственный (VALUE), прямой (DIRECT) и косвенный (INDIRECT) способы адресации.  
В первом случае, аргумент команды интерпретируется как значение, во втором - лейбл или число будут интерпретированы как адрес памяти, по которому находится значение, в третьем случае - лейбл или число будут интерпретированы как адрес, по которому в памяти находится адрес искомого значения.

Таким образом

- аргумент является значением - **VALUE**
- аргумент инструкции представляет собой адрес, по которому в памяти располагается искомое значение - **DIRECT**
- аргумент инструкции представляет собой адрес, по которому в памяти располагается адрес, по которому располагается искомое значение - **INDIRECT**

Наличие нескольких уровней косвенности расширяет возможности программиста по манипулированию данными, например, позволяет хранить в памяти адрес текущего элемента массива или строкогого литерала с возможностью загрузки его в аккумулятор одной инструкцией.

### Инструкции

Инструкция может быть двух видов:

- без операндов (не требующая аргументов)

- унарной (требовать 1 аргумент)

В инструкциях с аргументами, последние могут быть значениями, указателями на значение в памяти, указателями на указатель на значение в памяти и значениями по адресу ячейки памяти.  
По умолчанию, числа интерпретируются как значения, а лейблы как адреса. Для обращения интерпретации чисел как адресов, а лейблов - как значений по адресу, перед ними следуюет поставить символ "*". Для 

#### Набор инструкций

| Оператор | Инструкция | Операнды | Кол-во тактов | Описание |  
|---|---|---|---|---|  
| ld | Load | адрес / значение по адресу | 5 - 8 | Загрузка в аккумулятор значения из памяти по указанному адресу |  
| st | Store | адрес | 6 - 9 | Запись в память по указанному адресу значения из аккумулятора |  
| in | Input | номер порта | ? | Ввод значения с указанного порта в аккумулятор |  
| out| Output | номер порта | ? | Вывод значения из аккумулятора на указанный порт вывода |  
| add | Addition | значение по адресу / значение | 5 - 8 | Сложение значения параметра с значением из аккумулятора с последующей записью результата в аккумулятор |  
| sub | Substraction | значение по адресу / значение | 5 - 8 | Вычитание значения аргумента из значения аккумулятора с последующей записью результата в аккумулятор |  
| cmp | Compare | значение по адресу / значение | 5 - 8 | Вычитание значения аргумента из значения аккумулятора без записи результата в аккумулятор |  
| inc | Increment | - | ? | Инкрементация значения аккумулятора |  
| dec | Decrement | - | ? | Декрементация значения аккумулятора |  
| mul | Multiplication | значение по адресу / значение | 5 - 8 | Умножение значения параметра с значением из аккумулятора с последующей записью в аккумулятор |  
| div | Division | значение по адресу / значение | 5 - 8 | Деление значения из аккумулятора с значением параметра с последующей записью в аккумулятор |  
| mod | modulo | значение по адресу / значение | 5 - 8 | Получение остатка от деления значения из аккумулятора со значением параметра с последующей записью в аккумулятор |  
| or | Logical "Or" | значение по адресу / значение | 5 - 8 | Логическое "ИЛИ" между аккумулятором и значением параметра с последующей записью результата в аккумулятор. |  
| and | Logical "And" | значение по адресу / значение | 5 - 8 | Логическое "И" между аккумулятором и значением параметра с последующей записью в аккумулятор. |  
| lsl | Logical bit shift left | - | 5 | логический сдвиг битов аккумулятора влево |  
| asr | Arithmetic bit shift right | - | 5 | арифметический сдвиг битов аккумулятора вправо |  
| jmp | Jump | адрес инструкции | 5 - 8 | Безусловное изменение значения регистра-счётчика команд (PC) на значение параметра. |  
| jz | Jump if Zero | адрес инструкции | 6 - 9 | Изменение значения регистра IP на значение параметра при значении 1 в регистре Z. |  
| jnz | Jump if Not Zero | адрес инструкции | 6 - 9 | Изменение значения регистра PC на значение параметра при значении 0 в аккумуляторе. |  
| jn | Jump if Negative | адрес инструкции | 6 - 9 | Изменение значения регистра PC на значение параметра при значении 1 в аккумуляторе. |  
| jp | Jump if Positive | адрес инструкции | 6 - 9 | Изменение значения регистра PC на значение параметра при значении 0 в аккумуляторе. |  
| int | interuption | номера обработчика прерывания | 12 | Вызов определенного обработчика прерываний |  
| fi | finish interruption | - | 8 | Завершить обработку прерывания, вернуть аккумулятор и PC в состояние "как до прерывания" |  
| eni | enable interution | - | 5 | Разрешить прерывания |  
| dii | disable interuption | - | 5 | Запретить прерывания |  
| nop | no operation | - | 5 | Ничего не выполнять |
| hlt | halt | - | 4 | Остановить работу машины |

### Кодирование инструкций

- Машинный код сериализуется в список формата JSON.
- Один элемент списка - одна машинная инструкция.
- Индекс списка - адрес инструкции в памяти и адрес инструкции в машинном коде. Используется для команд перехода.

Пример:

``` machine code
[
    {
        "index": 0,
        "opcode": "jmp",
        "arg": 1,
        "mode": "direct",
        "line": 2
    },
    {
        "index": 1,
        "label": "a",
        "value": "x",
        "line": 4
    }
]
```

В примере, представленом выше:

- index - место выражения в памяти при работе программы.
- opcode - код инструкции.
- arg - аргумент инструкции, если предусмотрен конкретной инструкцией.
- mode - способ адресации данных в инструкциях.
- label - метка ячейки памяти для упрощения (программисту) доступа к ней на этапе написаниия программы.
- value - значение терма данных, сохраняемое в памяти.
- line - местоположение инструкции в исходном коде программы.

Типы данных для реализации инструкций (файл [isa.py](/src/isa.py)):

- Opcode - перечисление кодов инструкций.
- SourceTerm - выражение, представляющее собой одну строку исходного кода, разделённую через специальные символы.
- StatementTerm - Opcode инструкции и её аргумент (опционально), а также индекс в памяти, место в исходном коде, режим адресации аргумента (опционально) и лейбл в исходном коде (опционально)

### Устройство ввода/вывода

См. раздел [Ввод / вывод](#ввод--вывод)

### Поток управления

- инкремент PC после каждой инструкции.
- инструкции для осуществления условного (jz) и безусловного (jmp) переходов.
- прерывания (см. разделы [Прерывания](#прерывания) и [Ввод/Вывод](#ввод--вывод))

#### Прерывания

Прерывания могут быть программными и аппаратными. Аппаратные прерывания маскируемы, т.е. могут быть проигнорированны, однако программные прерывания могут быть вызваны всегда (т.к. процессор с одним потоком управления и другое программное прерывание не может быть вызвано неявно для программиста).  

Маскирование (запрет) аппаратных прерываний осуществляется установкой флага IR в "0" (по умолчанию), а разрешение - "1".

Вызов аппаратных прерываний происходит во время [цикла обработки прерывания](#циклы-исполнения-команд) при условии, что IR в состоянии "1".

Перед началом прерывания значения аккумулятора и счётчика команд сохраняются на фиксированные ячейки памяти для продолжения работы программы после прерывания.
Прерывания должны исполняться последовательно, чтобы выполнение программы полсле обработки прерывания могло быть продолжено корректно. Задача управления разрешением и запретом прерываний, а также исключения вызова прерываний внутри друг друга возложена на программиста.

Обработчики прерываний (см. раздел [Отображение данных на память](#механика-отображения-программы-и-данных-на-память)) хранятся в *векторе прерываний*. По умолчанию, вектор прерываний не инициализирован, поэтому при необходимости использования прерываний, программист должен вручную заполнить вектор прерывания необходимыми значениями (см. [пример](/examples/io_example.asm))
Каждый элемент в векторе прерываний отвечает за устройство ввода/вывода, подключённое к порту с номером, соответсвующим номеру элемента вектора прерывания. Однако нет необходимости писать одинаковые обработчики - можно загрузить в разные элементы вектора прерывания одинаковые адреса обработчиков прерываний.
Ещё одной обязанностью программиста является написание программы, определяющей номер устройства, запросившего прерывание ([пример](/examples/io_example.asm) такой программы).

За счёт использования последовательного интерфейса SPI, работа прерываний имеет нектороые особенности (см. раздел [Прерывания в SPI](#прерывания-в-spi))

Итак, программист должен:

- Следить за разрешениями / запретами использования прерываний по ходу работы всей его программы
- В начале программы загружать адреса обработчиков прерываний в соответствующие элементы вектора прерываний
- В начале прерывания сохранять номер прерывания (будет загружен в аккумулятор)
- Самостоятельно обнулять регистр запроса прерываний в устройстве, вызвавшем прерывание

## Транслятор

Производит трансляцию кода на разработаном диалекте ассемблера в машинный код формата JSON для разработанной машины.

### Интерфейс командной строки

Представляет собой python-скрипт, работающий как консольное приложение - при запуске требуется 2 аргумента:

- файл с исходным кодом на ассемблере
- файл, в который следует сохранить машинный код

### Принцип работы

1. На вход скрипта принимается исходный код на ассемблере.
2. Происходит разделение каждой строки исходного кода на термы.
3. Термы разделяются на две логические секции: данные и инструкции.
4. Производится преобразование и валидация термов из секции данных в термы данных.
5. Производится преобразование и валидация термов из секции инструкций в термы инструкций.
6. Производится отображение всех полученных термов на адресное пространство памяти.
7. Происходит преобразование лейблов - аргументов инструкций в адреса, на которые лейблы указывают.
8. Полученный машинный код сохраняется в целевой файл.

Примечание: вопросы отображения переменных на регистры опущены из-за отсутствия переменных на синтаксическом уровне.

## Модель процессора

### DataPath

...

#### Ввод / вывод

В качестве интерфейса ввода/вывода выступает синхронный последовательный интерфейс ввода/вывода SPI.  
SPI предполагает возможность наличия нескольких участников обмена данными и разделение их на две категори: Master и Slaves, а также использует 4 сигнала для осуществления обмена данными:

- MOSI - выход ведущего, вход ведомого
- MISO - вход ведущего, выход ведомого
- SCLK - последовательный тактовый сигнал
- CS - выбор устройства для обмена данными

Также присутствует 5-ый сигнал - INT (см. раздел [Прерывания в SPI](#прерывания-в-spi))

#### Конфигурация SPI

Используется конфигурация SPI, в которой Master - [контроллер SPI](#устройство-контроллера-spi), подключённый к процессору, управляет осуществлением обмена данными и генерирует тактовый сигнал; а Slave - все переферийные устройства. Тактовый генератор располагается в контроллере SPI и подключён к шине SCLK # todo.

Режим работы интерфейса (см. [Wiki](https://ru.wikipedia.org/wiki/Serial_Peripheral_Interface#Режимы_работы_интерфейса_SPI)) в этой реализации неизменяем и является режимом 0 (исходное состояние сигнала синхронизации - низкий уровень и выборка данных производится по переднему фронту (переключению) сигнала синхронизации)

#### Прерывания в SPI

В следствие необходимости реализации прерываний, SPI дополнен компонентами, позволяющими использовать логику прерываний с этим интерфейсом:

- Помимо сдвигового регистра, присутсвиует битовый регистр IRS (флаг запроса прерывания подчинённого (slave)).
- Помимо стандартных портов CS, SCLK, MOSI, MISO, в каждом утройстве присутствует порт INT, работающий на вывод состояния регистра IR.
- К порту подключены провода, ведущие на шину прерываний процессора, подключенную к регистру прерываний IRQ, и на шину данных, подключённую к аккумуляторному регистру.
- Регистр IRS устанавливается в единицу при готовности устройства вывести данные.
- 

#### Устройство контроллера SPI

- Демультиплексор для генерации сигнала CS (осуществления выбора устройства для обмена данными).
- Таймер для генерации сигналов SCLK.
- Порты для подключения сигналов MOSI, MISO, SCLK, CS, INT.



### Control Umit

#### Циклы исполнения команд


...

## Тестирование

Разработаны модульные тесты для следующих модулей проекта:

- Системы команд
- Транслятора
- Машины

А так же интергационные тесты для всех вышеперечисленных и Устройств ввода/вывода

### Настройка CI

CI сконфигурирован для использования платформы GitLab. Создаётся Docker - образ, содержащий последнюю версию интерпретатора Python, образ загружается на облачные сервера GitLab, происходит настройка окружения для проведения необходимых работ (загрузка необходимых пакетов) и запускаются работы.

Работы (jobs), проводимые при запуске CI:

- test-coverage - "прогон" тестов с утилитой coverage.
- lint - проверка исходного кода на python линтером ruff.
- type-check - проверка типизации исходного кода на python инструментом mypy.

### Базовые тесты
